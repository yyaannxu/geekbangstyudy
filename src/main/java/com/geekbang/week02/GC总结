1：判断对象是否存活算法：
    （1）引用计数法：计算当前所持有的引用，当持有的引用大于等于1的时候，证明对象是还在使用状态，因此不能进行
    垃圾回收。
    缺点：可能会出现循环引用的问题。当两个对象彼此互相持有对方的引用的时候，这两个对象就会一直不能被回收。
    （2）可达性分析：从 GC ROOT 出发进行遍历，由根对象出发遍历直接引用和间接引用的对象，
    这些对象就是可达对象，可达的对象说明程序正在使用。是不够被回收的。

2：不同GC:
    （1）串行GC(Serial GC) 是单线程的垃圾收集器，不能进行并行处理。所以不能充分利用多核cpu资源。当堆内存比较大，
    进行full gc的时候，可能需要回收大量的老年代的垃圾时，此时gc暂停的时间就会比较长。
    （2）并行GC(Parallel GC) 是一个多线程的垃圾回收器。我们可以使用 -XX:ParallelGCThreads=N 来指定GC的
    线程数。默认情况下为CPU核心数。并行的垃圾回收器可以充分利用cpu资源。因此可以达到更高的吞吐量。
    （3）CMS 垃圾回收器的作用主要是为了减少full gc的时候，出现长时间的gc暂停。使用cms 垃圾回收器会只有在初始标记和
    最终标记的时候出现gc暂停。其他大部分的工作是和应用线程一起工作的。csm默认情况下使用的线程数是cpu核数的1/4。
    （4）G1 垃圾回收器。堆不再分成年轻代和老年代。而是划分成多个小块。region.  每一个小块可能一会被定义成Egen,
    一会被定义成survivor,一会被定义成old。